# 计算机系统概述

## 硬件

> 字
- 64位 8字节
- 32位 4字节
字节 8bit

### 冯·诺依曼机：控制流驱动方式
- 以运算器为中心
- 由五大部件组成
- 指令和数据用二进制表示，同等地位存于存储器，按地址寻访
- 指令由操作码和地址码组成
- 存储程序

### 发展历程

- 第一代 电子管
- 第二代 晶体管
- 第三代 中小规模集成电路
- 第四代 大规模、超大规模集成电路

### 硬件组成

**存储器**
- 存储体
- 存储地址寄存器MAR
- 存储数据寄存器MDR

**运算器**
- 累加器ACC
- 乘商寄存器MQ
- 操作数寄存器X
- **算术逻辑单元ALU**：实现各种算术运算逻辑运算

**控制器**
- **控制单元CU**：给出控制信号，执行指令
- 指令寄存器IR：分析当前指令
    > 对程序员透明
- 程序计数器PC：下一条指令地址
    > 可通过JMP设置

### 工作流程
- 指令、数据存入主存，PC指向第一条指令
- 从主存取指令放入IR，PC自动加一，CU分析指令，CU指挥其他部件执行指令

## 软件
> 指令集体系结构ISA：定义计算机支持哪些指令、作用、用法

翻译程序
- 高级语言
    > ↓编译 编译器
- 汇编语言
    > ↓汇编 汇编器
- 机器语言

- 高级语言
    > 编译：一次性
    > 解释 解释器：边翻译边执行
- 机器语言

## 层次结构
- 虚拟机器 高级语言
- 虚拟机器 汇编语言
- 虚拟机器 操作系统（提供广义指令/系统调用）
- 传统机器 机器语言
- 微程序机器 微指令系统（硬件执行微指令）

## 工作原理
- 源程序 `.c`
    > ↓预处理器
- 预处理后的源程序 `.i`
    > ↓编译器
- 汇编语言程序 `.s`
    > ↓汇编器
- 机器语言程序（目标模块）+其他被引目标模块 `.o`
    > ↓链接器
- 可执行文件 `.exe`

## 性能指标

**存储器**
- MAR位数 存储单元个数为$2^n$
- MDR位数 存储单元字长（大小）
容量=存储单元个数*存储字节（bit）
> 文件大小$K=2^10$ $M=2^20$ $G=2^3$0 $T=2^40$

**CPU**
- 主频f：1/时钟周期T
- CPI：每条指令所需的时钟周期数
- CPU耗时：指令数量*CPI/主频
- 每秒执行多少条指令IPS：主频/CPI
- 浮点运算FLOPS
- 机器字长：一次可处理的二进制代码长度
> 与通用寄存器、ALU长度相同

> 频率、数量级$K=10^3$ $M=10^6$ $G=10^9$ $T=10^12$

**系统**
- 数据通路带宽：数据总线并行传送信息的位数
- 吞吐量：单位时间内处理请求数量
- 响应时间：从发送请求到做出响应（得到结果）的时间

> 指令系统等方面同样会影响

# 数据的表示和运算

## 进位计数制

- 二进制B
- 十进制D
- 0x十六进制H
> 除n取余（倒过来），乘n取整（正着，可能循环）

- 真值 符合人类习惯，带正负号
- 机器数 将正负号数字化
    > 计算机内部有符号位为补码，直接看成二进制
    > 主存全是正数，只需要无符号位

## 定点数 
- 无符号数 没有符号位
    > 通常只有整数
- 有符号数（分开表示）
    - 定点整数 符号位 数值部分 小数点位置（隐含）
    - 定点小数 符号位 小数点位置（隐含） 数值部分

- **原码** $n+1$位表示范围位$±(2^n-1)$/$1-2^{-n}$（正负0占两个）
- **反码** 符号位为0相同，符号位为1**尾数**取反，其余同原码
- **补码** 符号位为0相同，符号位为1反码**尾数**+1（0只有1个，多表示$-2^n$）
    > 原码 ↔ 补码：按位取反，然后+1
    > 从$[x]_补$求$[-x]_补$：符号、数值位全部取反，末位+1（**最右边的1及其右边是原码，左边同反码**）
    > 0开头1越多越大，1开头0越多越小（-127）
- **移码** 补码符号位取反，全0最小，全1最大
> 偏置值（将有符号数转化为无符号数存储）：真值=移码转为十进制-偏置值

> 原码、反码、补码：定点整数和小数
> 移码：定点整数

### 移位

- 逻辑移位（无符号）
  - 左移n位：高位丢弃，低位补0（$*2^n$）
    > 高位丢弃1，发生溢出
  - 右移n位：低位丢弃，高位补0（$/2^n$）
    > 低位丢弃1，丢失精度
- 算术移位（带符号）
  - 左移n位：高位丢弃，低位补0（$*2^n$）
    > 符号位变1，发生溢出
  - 右移n位：低位丢弃，**高位补符号位**（$/2^n$）
    > 低位丢弃1，丢失精度

`x>>1` 右移 

### 加减运算

#### 无符号数
溢出判断（范围$0~2^n-1$）
- 加法：最高位进位为1
- 减法：最高位进位为0

#### 带符号数
> 移位使用补码运算，**减法时低位进位为1**
原码
- 正+正：绝对值做加法，符号取0
- 负+负：绝对值做加法，符号取1
    > 以上两种情况可能溢出
- 正+负：绝对值大-绝对值小，符号同绝对值大

**溢出判断（补码）**
- 一位符号位：上溢：正正得负；下溢：负负得正
- 一位符号位：符号位$C_0$进位与最高数值位$C_1$进位不同则溢出
- 双符号位/变形补码：符号位相同则没有溢出
- 转换为**真值比较**

> 双符号位补码；模4补码，单符号位补码：模2补码
> 实际存储时只存储一个符号位

> a的补数：模-|a|（+补码）
> 字长n位的计算机天然完成$\mod n$运算

### 乘除运算

#### 无符号数
- 乘法
    > 高n位不全为0则溢出
- 除法
    > 除数为0异常
    > 
#### 带符号数
- 乘法（符号位参与运算）
  - 数值位按绝对值相乘
  - 符号位异或确定正负
- 除法

#### 实现乘法的三种方式
- ALU、移位器、寄存器、控制逻辑组成
    > n位相乘需要n个时钟，使用两位乘法时需要n/2个时钟
- 阵列乘法器
    > 处理乘法需要1个时钟（快速乘法器基本都可以）
- 移位运算、加减运算等效
    > 每条指令都需要1个时钟



### 零扩展和无符号扩展
- 无符号整数 填充0
- 带符号整数 填充符号位（不改变数据）

### 逻辑门
- 优先级：括号>非>与>或
- 多路选择器MUX
    > 可能预留1个控制信号拦截所有输入
- 三态门
> n bit进行异或，奇数个1时结果为1

### 加法器

- 一位全加器
- n bit加法器（串行进位的并行加法器）
    > 串行指进位信息，并行指输入
- 并行进位的并行加法器
- 带标志位的加法器
  - OF溢出标志 有符号数据溢出`1`或未溢出`0`
  - SF符号标志 `1`为负`0`为正
  - ZF零标志 `1`结果为零 `0`结果非零
  - CF进位/借位标志
    - 无符号数溢出`1`或未溢出`0`
    - 判断是否需要借位
    > 标志被送入PSW/FR标志寄存器

### 算数逻辑单元ALU

- 算术运算
- 逻辑运算
- 其他（求补码、直送）
> 若ALU支持k种功能，则控制信号位数$m>\lceil log_2 k \rceil$
> LU的运算数、运算结果位数与机器字长相同
> 电路实现：k个功能电路+多路选择器MUX

### 强制类型转换
- 无符号位与有符号位：不改变数据
    > 有符号数（含符号位）按位取反+1，正常读数
    > 无符号数取反+1，首位为符号位，正常读数
- 长整数变为短整数：只保留低位，首位会改变大小（**按补码解释**，取反+1求原值）
> c语言中定点整数用**补码**存储

**转换规律（从上到下）**
- char
- int $2^{32}-1$
- long $2^{64}-1$（64位系统）
- (float) $(2−2^{23})*2^{127}$
    >  float参与运算时会被提升到double
- double $(2−2^{52})*2^{1023}$
> 浮点数`float`、`double`转整型`int`会截断
> 长转短会丢高位

## 浮点数

- 阶码：范围
- 尾数：精度
- 基数：所乘数
- 规格化：1.0x（**精度**）
> 补码尾数规格化：符号位与最高数值为相反
> 原码尾数规格化：正数为`0.1`，复数为`1.0`

- float：32位单精度
  - 符号（1bit）
  - 阶码（8bit）
    > 使用移码读取，偏置值为127（真值+偏置值，按无符号整数规则转化）
  - 尾数（23bit）
    > 小数点位置在23bit前，隐含小数点前的1

- double：64位双精度
  - 符号（1bit）
  - 阶码（11bit）
    > 偏置值为1023（$2^{n-1}-1$）
  - 尾数（52bit）

### 特殊的浮点数
  - 阶码全0
    - 尾数为0 0
    - 尾数非0 非正规数
    > 非正规数$=(-1)^s*2^{-126}*(0.f)$
    > $(0.f)$尾数（如`010……0`为$2^{-2}$）
  - 阶码全1
    - 尾数为0 无穷大
    - 尾数非0 非数值

### 浮点数范围
- 偏移量$bias=2^{n-1}-1$
- n位阶码
  - 最大表示$2^n-1-$偏移量$=2^{n-1}-1$
  - 最小表示$1-$偏移量$=2-2^{n-1}$
- m位尾数
  - 最大表示$1+(1-2^{-m})$
  - 最小表示$1$
- 浮点数
  - 最大正数$=(2-2^{-m})*2^{2^{-1}}$
  - 最小正数$=(2-2^{n-1})$

### 转换

**左规**（数字**左**移，小数点右移）
- 下溢：太接近0丢失精度
- 底数变大，指数变小

**右规**（数字**右**移，小数点左移）
- 上溢：超出表示范围
- 底数变小，指数变大

> 右规、对阶可能导致舍入
> 尾数溢出结果不一定溢出

**对阶**
1. 小的右移

**真值转浮点数**
1. 将**真值**转化为二进制
2. 确定每部分位数
3. 将**尾数**规格化
4. **阶码**真值+移码偏置值，按照无符号整数转化为移码
5. 确定各部分数值，注意规格化尾数第一个1隐含

**浮点数转真值**
1. 确定每部分位数
2. 确定符号、阶码、尾数二进制数
   1. 按无符号整数求阶码-偏置值
   2. 确定尾数（记住1）

### 大小端和对齐存储

- 最高有效字节MSB；最低有效字节LSB

- 大端 从低到高（人类书写习惯，方便阅读）
- 小端 从高到低（方便处理） 
> 指内存地址

- 编址方式：字节
- 寻址方式：字、半字、字节（访存只能读/写1字）

#### 边界对齐
> 根据字长确定，不能被分割
- char 1字节（补1字节）
- short 2字节
- int/unsigned 4字节

# 存储系统

## 基本概念

> 命中率：

### 层次
- 寄存器
- 高速缓冲存储器Cache
- 内存/主存
> 以上可直接被CPU读写
- 辅存
- 外存

### 分类

- 存储介质
  - 半导体存储器
  - 磁表面存储器
  - 光存储器
- 存储方式
  - 随机存取存储器RAM 读写时间与位置无关 （）
  - 顺序存取存储器SAM 读取时间与位置有关 （）
  - 直接存取存储器DAM 兼而有之 （磁盘）
  - 相联存储器CAM 按照内容和地址检索（快表）
- 可更改性
  - 读写存储器R/WM
  - 只读存储器ROM
- 可保存性
  - 易失性/非易失性存储器 断电后存储信息是否消失
  - 破坏/非破坏性存储器 信息读出后是否会被破坏
    > DRAM读出重写

### 性能指标
- 存储容量：存储字数*字长（MDR位数）
- 单位成本：每位价格=总成本/总容量
- 存储速度：速度传输率=数据宽度/存储周期
- 存取时间$T_a$：启动到完成操作
- 存取周期$T_m$：存取时间$T_a$+恢复时间，两次独立访问中间的间隔
- 主存带宽/信号传输率$B_m$

## 主存储器

半导体元件原理
- 存储体/矩阵→存储单元/字→存储元→电容+MOS管
- 译码器
- MAR
- 片选线
- 读/写控制线WE/OE

存储芯片
- 数据线
- 读写控制线
- 片选线
- 地址线 n位地址

寻址

### 易失性存储器RAM

- $容量=2^{地址线}*数据线$



#### 静态SRAM（Cache）
- 双稳态触发器
- 不断电数据不会消失
- 同时送行列地址

#### 动态DRAM（主存）
- 栅极电容
- 电容自放电 需要刷新(2ms)
    > 以**行**为单位（行列地址）
    > 读出后重新写入 1读/写周期（0.5us）
    > - 分散刷新 每次读写完刷新一行 存取周期变为1us(1/2正常读写1/2刷新某行)
    > - **集中刷新** 存储单元数量开平方为 存在无法访问存储器的“访存死区”
    > - **异步刷新** 每2ms/存储单元数量开平方=us刷新一次（存在死时间）
- 破坏性读出，需要重写
- 地址线复用技术：分两次送行列地址，地址线减半

> SDRAM：同步交换数据
> 异步刷新：、列数，刷新时间除以行列书为周期


### 只读存储器

- 掩模式只读存储器MROM 不可重写
- 可编程只读存储器PROM 写一次不可更改
- 可擦除可编程只读存储器EPROM 可多次重写
  - UVEPROM 紫外线照射可擦除所有信息
  - EEPROM 电擦除特定字
- 闪存 多次快速擦除重写
    > 先擦除再重写，写慢于读
- SSD 多次快速擦除重写


### 多模块存储器

~~双端口RAM~~

- 单体多字存储器
    > 一次并行读取m个字，总线宽度扩展为m
- 多体并行存储器
  - 高位交叉编址 连续读取时处于同一存储体，需要等待恢复
  - **低位交叉编址** 存储体各数$m\geq T/r$时不间断 
    > 按体号和体内地址的先后顺序来区分

### 存储器与CPU的连接
> 横线为低电平有效

- 字扩展
  - 线选法
  - 译码器片选法
- 位扩展
- 字位同时扩展
> 内存总线的低位地址用于片内寻址
> 地址线只和单个存储单元有关

### 外存储器
- 磁盘存储器
  - 盘面-磁道-扇区
- 固态硬盘

### 高速缓冲存储器Cache
> 交换数据单位：块(CPU)/页（主存）=行（Cache）
> 被访问的主存一定会立即调入Cache

- 空间局部性：频繁调用
- 时间局部性：地址连续

**访存策略**（Cache和主存的对应关系）
- 全相联映射（任意位置）
    > 
- 直接映射（固定位置）`1位有效位`
    > $位置=主存块号\%Cache总块数$
    > 行号$=log_2(行数)$
- 组相联映射（特定分组）
    > $所属分组=主存块号\%分组数$
    > $主存块号=地址/主存块大小$
    > $组号=行数/n组$

**替换算法**（Cache满了如何解决）
> **全相联映射** Cache满后全局替换
> **组相联映射** 分组满后组内替换
- **随机算法**RAND
- **先进先出算法**FIFO 存在抖动问题
- 📌**近期最少使用算法**LRU 统计多久没使用
- **最不经常使用算法**LFU 
> Cache块$2^n$时，需要n位计数器

> Cache地址
> 1. 计算地址总长度
> 2. 🔻计算Cache总块数
> 3. 计算组号（地址线连接字节）
> 4. 计算块内偏移（Byte）

**写策略**（如何确保Cache和主存的一致性）
- 写命中
  - **全写法** 同时写入Cache和主存（写缓冲）
  > 一致性高，写不频繁
  - **写回法** `1位脏位` 修改Cache不写入主存，换出时写入
  > 写频繁，可容忍短暂不一致
- 写不命中
  - **写分配法** 从主存调入Cache并修改（写回法）
  - **非写分配法** 只写入主存

### 虚拟内存

# 指令系统