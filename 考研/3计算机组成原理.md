# 计算机系统概述

## 硬件

> 字
- 64位 8字节
- 32位 4字节
字节 8bit

### 冯·诺依曼机：控制流驱动方式
- 以运算器为中心
- 由五大部件组成
- 指令和数据用二进制表示，同等地位存于存储器，按地址寻访
- 指令由操作码和地址码组成
- 存储程序

### 发展历程

- 第一代 电子管
- 第二代 晶体管
- 第三代 中小规模集成电路
- 第四代 大规模、超大规模集成电路

### 硬件组成

**存储器**
- 存储体
- 存储地址寄存器MAR
- 存储数据寄存器MDR

**运算器**
- 累加器ACC
- 乘商寄存器MQ
- 操作数寄存器X
- **算术逻辑单元ALU**：实现各种算术运算逻辑运算

**控制器**
- **控制单元CU**：给出控制信号，执行指令
- 指令寄存器IR：分析当前指令
    > 对程序员透明
- 程序计数器PC：下一条指令地址
    > 可通过JMP设置

### 工作流程
- 指令、数据存入主存，PC指向第一条指令
- 从主存取指令放入IR，PC自动加一，CU分析指令，CU指挥其他部件执行指令

## 软件
> 指令集体系结构ISA：定义计算机支持哪些指令、作用、用法

翻译程序
- 高级语言
    > ↓编译 编译器
- 汇编语言
    > ↓汇编 汇编器
- 机器语言

- 高级语言
    > 编译：一次性
    > 解释 解释器：边翻译边执行
- 机器语言

## 层次结构
- 虚拟机器 高级语言
- 虚拟机器 汇编语言
- 虚拟机器 操作系统（提供广义指令/系统调用）
- 传统机器 机器语言
- 微程序机器 微指令系统（硬件执行微指令）

## 工作原理
- 源程序 `.c`
    > ↓预处理器
- 预处理后的源程序 `.i`
    > ↓编译器
- 汇编语言程序 `.s`
    > ↓汇编器
- 机器语言程序（目标模块）+其他被引目标模块 `.o`
    > ↓链接器
- 可执行文件 `.exe`

## 性能指标

**存储器**
- MAR位数 存储单元个数为$2^n$
- MDR位数 存储单元字长（大小）
容量=存储单元个数*存储字节（bit）
> 文件大小$K=2^10$ $M=2^20$ $G=2^3$0 $T=2^40$

**CPU**
- 主频f：1/时钟周期T
- CPI：每条指令所需的时钟周期数
- CPU耗时：指令数量*CPI/主频
- 每秒执行多少条指令IPS：主频/CPI
- 浮点运算FLOPS
- 机器字长：一次可处理的二进制代码长度
> 与通用寄存器、ALU长度相同

> 频率、数量级$K=10^3$ $M=10^6$ $G=10^9$ $T=10^12$

**系统**
- 数据通路带宽：数据总线并行传送信息的位数
- 吞吐量：单位时间内处理请求数量
- 响应时间：从发送请求到做出响应（得到结果）的时间

> 指令系统等方面同样会影响

# 数据的表示和运算

## 进位计数制

- 二进制B
- 十进制D
- 0x十六进制H
> 除n取余（倒过来），乘n取整（正着，可能循环）

- 真值 符合人类习惯，带正负号
- 机器数 将正负号数字化
    > 计算机内部有符号位为补码，直接看成二进制
    > 主存全是正数，只需要无符号位

## 定点数 
- 无符号数 没有符号位
    > 通常只有整数
- 有符号数（分开表示）
    - 定点整数 符号位 数值部分 小数点位置（隐含）
    - 定点小数 符号位 小数点位置（隐含） 数值部分

- **原码** $n+1$位表示范围位$±(2^n-1)$/$1-2^{-n}$（正负0占两个）
- **反码** 符号位为0相同，符号位为1**尾数**取反，其余同原码
- **补码** 符号位为0相同，符号位为1反码**尾数**+1（0只有1个，多表示$-2^n$）
    > 原码 ↔ 补码：按位取反，然后+1
    > 从$[x]_补$求$[-x]_补$：符号、数值位全部取反，末位+1（**最右边的1及其右边是原码，左边同反码**）
    > 0开头1越多越大，1开头0越多越小（-127）
- **移码** 补码符号位取反，全0最小，全1最大
> 偏置值（将有符号数转化为无符号数存储）：真值=移码转为十进制-偏置值

> 原码、反码、补码：定点整数和小数
> 移码：定点整数

### 移位

- 逻辑移位（无符号）
  - 左移n位：高位丢弃，低位补0（$*2^n$）
    > 高位丢弃1，发生溢出
  - 右移n位：低位丢弃，高位补0（$/2^n$）
    > 低位丢弃1，丢失精度
- 算术移位（带符号）
  - 左移n位：高位丢弃，低位补0（$*2^n$）
    > 符号位变1，发生溢出
  - 右移n位：低位丢弃，**高位补符号位**（$/2^n$）
    > 低位丢弃1，丢失精度

### 加减运算

#### 无符号数
溢出判断（范围$0~2^n-1$）
- 加法：最高位进位为1
- 减法：最高位进位为0

#### 带符号数
> 移位使用补码运算，**减法时低位进位为1**
原码
- 正+正：绝对值做加法，符号取0
- 负+负：绝对值做加法，符号取1
    > 以上两种情况可能溢出
- 正+负：绝对值大-绝对值小，符号同绝对值大

溢出判断（补码）
- 一位符号位：上溢：正正得负；下溢：负负得正
- 一位符号位：符号位$C_0$进位与最高数值位$C_1$进位不同则溢出
- 双符号位：符号位相同则没有溢出
- 转换为**真值比较**

> 双符号位补码；模4补码，单符号位补码：模2补码
> 实际存储时只存储一个符号位

> a的补数：模-|a|（+补码）
> 字长n位的计算机天然完成$\mod n$运算

### 乘除运算

#### 无符号数
- 乘法
    > 高n位不全为0则溢出
- 除法
    > 除数为0异常
    > 
#### 带符号数
- 乘法（符号位参与运算）
  - 数值位按绝对值相乘
  - 符号位异或确定正负
- 除法

#### 实现乘法的三种方式
- ALU、移位器、寄存器、控制逻辑组成
    > n位相乘需要n个时钟，使用两位乘法时需要n/2个时钟
- 阵列乘法器
    > 处理乘法需要1个时钟（快速乘法器基本都可以）
- 移位运算、加减运算等效
    > 每条指令都需要1个时钟

### 强制类型转换
- 无符号位与有符号位：不改变数据
    > 有符号数（含符号位）按位取反+1，正常读数
    > 无符号数取反+1，首位为符号位，正常读数
- 长整数变为短整数：只保留低位，首位会改变大小（**按补码解释**，取反+1求原值）
> c语言中定点整数用**补码**存储

### 零扩展和无符号扩展
- 无符号整数 填充0
- 带符号整数 填充符号位（不改变数据）

### 逻辑门
- 优先级：括号>非>与>或
- 多路选择器MUX
    > 可能预留1个控制信号拦截所有输入
- 三态门
> n bit进行异或，奇数个1时结果为1

### 加法器

- 一位全加器
- n bit加法器（串行进位的并行加法器）
    > 串行指进位信息，并行指输入
- 并行进位的并行加法器
- 带标志位的加法器
  - OF溢出标志 有符号数据溢出`1`或未溢出`0`
  - SF符号标志 `1`为负`0`为正
  - ZF零标志 `1`结果为零 `0`结果非零
  - CF进位/借位标志
    - 无符号数溢出`1`或未溢出`0`
    - 判断是否需要借位
    > 标志被送入PSW/FR标志寄存器

### 算数逻辑单元ALU

- 算术运算
- 逻辑运算
- 其他（求补码、直送）
> 若ALU支持k种功能，则控制信号位数$m>\lceil log_2 k \rceil$
> LU的运算数、运算结果位数与机器字长相同
> 电路实现：k个功能电路+多路选择器MUX

## 浮点数

- 阶码：范围
- 尾数：精度
- 基数：所乘数
- 规格化：确保位数的最高位非0数位在小数点前

- float：32位单精度
  - 符号（1bit）
  - 阶码（8bit）
    > 使用移码读取，偏置值为127（真值+偏置值，按无符号整数规则转化）
  - 尾数（23bit）
    > 小数点位置在23bit前，隐含小数点前的1

- double：64位双精度
  - 符号（1bit）
  - 阶码（11bit）
    > 偏置值为1023（$2^{n-1}-1$）
  - 尾数（52bit）

- 特殊的浮点数

### 转换

**真值转浮点数**
1. 确定每部分位数
2. 将**真值**转化为二进制
3. 将**尾数**规格化
4. **阶码**真值+移码偏置值，按照无符号整数转化为移码
5. 确定各部分数值，注意规格化尾数第一个1隐含

**浮点数转真值**
1. 确定每部分位数
2. 确定符号、阶码、尾数二进制数
   1. 按无符号整数求阶码-偏置值
   2. 确定尾数（记住1）

### 大小端和对齐存储

- 最高有效字节MSB；最低有效字节LSB

- 大端（方便阅读） 从低到高
- 小端（方便处理） 从高到低
> 指内存地址

- 编址方式：字节
- 寻址方式：字、半字、字节（访存只能读/写1字）

- 边界对齐/不对齐

# 存储系统

## 基本概念

### 层次
- 寄存器
- 高速缓冲存储器Cache
- 内存/主存
> 以上可直接被CPU读写
- 辅存
- 外存

### 分类
- 存储介质
  - 半导体存储器
  - 磁表面存储器
  - 光存储器
- 存储方式
  - 随机存取存储器RAM 读写时间与位置无关
  - 顺序存取存储器SAM 读取时间与位置有关
  - 直接存取存储器DAM 兼而有之
  - 相联存储器CAM 按照内容检索（快表）
- 可更改性
  - 读写存储器R/WM
  - 只读存储器ROM
- 可保存性
  - 易失性/非易失性存储器 断电后存储信息是否消失
  - 破坏/非破坏性存储器 信息读出后是否会被破坏
    > DRAM读出重写

### 性能指标
- 存储容量：存储字数*字长（MDR位数）
- 单位成本：每位价格=总成本/总容量
- 存储速度：速度传输率=数据宽度/存储周期
- 存取时间$T_a$：启动到完成操作
- 存取周期$T_m$：存取时间$T_a$+恢复时间，两次独立访问中间的间隔
- 主存带宽/信号传输率$B_m$

## 主存储器

半导体元件原理
- 存储体/矩阵→存储单元/字→存储元→电容+MOS管
- 译码器
- MAR
- 片选线
- 读/写控制线WE/OE

存储芯片
- 数据线
- 读写控制线
- 片选线
- 地址线 n位地址

寻址

### 静态SRAM（Cache）
- 双稳态触发器
- 不断电数据不会消失
- 同时送行列地址

### 动态DRAM（主存）
- 栅极电容
- 电容自放电 需要刷新(2ms)
    > 以行为单位（行列地址）
    > 读出后重新写入 1读/写周期（0.5us）
    > - 分散刷新 每次读写完刷新一行 存取周期变为1us(1/2正常读写1/2刷新某行)
    > - 集中刷新 安排在2ms内全部刷新 存在无法访问存储器的“访存死区”
    > - 异步刷新 每2ms/128=15.6us刷新一次（0.5us死时间）
- 破坏性读出，需要重写
- 地址线复用技术：分两次送行列地址
