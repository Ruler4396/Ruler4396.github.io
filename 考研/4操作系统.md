# 计算机系统概述

> `PC` 程序计数器（均保存） `PSW` 程序状态字（硬件）

## 特征
**并发**（同一时间间隔，并行为同一时刻）
**共享**
- 互斥共享
- 同时共享

虚拟
- 空分复用（虚拟存储器）
- 时分复用（虚拟处理器）

异步（争抢资源）

## 分类
**批处理**
- 并发处理，提高资源利用率
- 无法人机交互

**分时**
- 以时间片轮流为各个用户/作业服务
- 无法处理紧急任务

**实时**
- 优先级

## 中断
- 内中断/异常 （访存缺页）
  - 陷入 下条指令
  - 故障 当前指令
  - 终止 当前指令/下条指令
  > Cache缺失由CPU硬件实现
  > 由软件识别
- 外中断 **断点：当前指令执行完后下一条**
  - I/O中断 
  - 时钟中断
  > 由软件/硬件识别
> 中断/异常**处理**由硬件响应

## 特权指令
**直接管理系统资源指令**
- 设置时钟
- 启动/关闭硬件
- 切换进程
- 设置中断

**系统状态修改指令**
- 修改中断向量表
- 切换CPU的运行模式

**系统控制指令**
- 停机指令
- 重启指令

## 系统调用（共享资源）
- 设备管理
- 文件管理
- 进程管理
- 进程通信
- 内存管理 

## 具体操作
**硬件**
- 保存断点和程序状态字
- 修改状态

**操作系统**
- 保存通用寄存器内容

## 体系结构
**分层**
- 便于试调和验证
- 效率低、单向依赖

**模块化**
- 动态加载新的内核模块、可以直接调用其他模块
- 互相依赖，更难调试和验证

**大内核**
- 性能高，可以互相调用
- 功能复杂难以维护、可靠性低

**微内核**
- 可靠稳定
- 性能较低，需要频繁切换状态，不能直接调用

**外核**
- 直接分配硬件资源，更加灵活，效率高
- 降低一致性

## 引导
1. CPU加电，CS：IP指向FFFF0H
2. JMP指令BIOS加载CMOS（ROM）`自举程序`
3. 硬件自检
4. 加载MBR 主引导记录（硬盘）`引导程序 启动管理器`
5. 扫描硬盘分区
6. 加载PBR 分区引导记录
> 中断向量表

#  进程与线程

**特征**
- **动态性**
- 并发性
- 独立性
- 异步性
- 结构性

## 进程实体/影响 
PCB
- 进程描述信息
- 进程控制和管理信息
- 资源分配清单
- 处理机相关信息

内存内容
- 正文段（代码与赋值数据，如常量，全局复制变量）
- 数据堆段（动态分配存储区）
- 数据栈段（临时使用变量，实参）

## 状态和转换
> 阻塞和唤醒成对出现

**运行态**
> ↓ 系统调用等主动行为

**阻塞/等待态**
> ↓ 资源被分配等被动行为

**就绪态**
创建态
终止态

## 进程控制
> 使用原语

### 创建
**创建原语**
- 申请空白PCB
- 为新进程分配所需资源
- 初始化PCB
- 将PCB插入就绪对垒

**事件**
- 用户登录
- 作业调度
- 提供服务
- 用户请求
- 不含~~设备分配~~

### 终止
**撤销原语**
- 从PCB集合中找到种植进程的PCB
- 剥夺CPU资源，分配给其他进程
- 终止所有子进程
- 将所有资源归还父进程或操作系统
- 删除PCB

**事件**
- 正常结束（自身）
- 异常结束（终止）
- 外界干预（用户）

### 阻塞

**阻塞原语**
- 找到要阻塞进程PCB
- 保护进程运行现场，将PCB状态信息设置成阻塞态，暂时停止进程运行
- 将PCB插入对应事件的等待队伍

事件
- 等待系统分配某种资源
- 等待互相合作的其他进程完成工作

### 唤醒

唤醒原语
- 在事件等待队列中找到PCB
- 将PCB从等待队列移除，设置进程为就绪态
- 将PCB插入就绪队列，等待被调度

事件
- 等待的事件发生

### 切换

**切换原语**
- 运行环境信息存入PCB
- PCB移入相关队列
- 选择另一个进程执行，更新PCB
- 更新PCB恢复新进程所需的运行环境

事件
- 当前进程时间片到

## 进程通信

1. 共享存储 互斥访问
   - 基于数据结构
   - 基于存储区
2. 套接字(Socket) 支持流和数据报
3. 消息传递 消息头/消息体
   - 直接
   - 间接 信箱 
4. 管道 单向/半双工
   - **多写一读**
   - 多写多读，轮流读取

信号 传递通知
- 内核态→用户态 检测待处理信号
- 内核对每种信号都有默认处理程序，自定义覆盖默认
- 部分信号不能被自定义，也不会被阻塞
- 同类信号将被丢弃

- 信号量 用于同步

## 线程
- 进程拥有系统资源
> 提高系统并发性、节约系统资源、便于进程通信

多线程模型

TCB线程控制块
- 线程标识符TID
- **程序计数器PC**
- **其他寄存器**
- **堆栈指针**
- 线程运行状态
- 优先级
线程切换时要保存/恢复、

内核级线程
用户级线程
- 一个被阻塞，其他也被阻塞
- 操作系统只能看到进程

- 进程和线程

## CPU调度
> 放到外存中的为挂起态

|名称|内容|发生位置|发生频率|影响|
|:-:|:-:|:-:|:-:|:-:|
|高级调度|从后备队列中选择合适作业调入内存|外存→内存（作业）|低|→创建态→就绪态|
|中级调度|从挂起队列中选择进程将其数据调回内存|外存→内存（进程）|中|挂起态→就绪态（阻塞挂起→阻塞态）|
|低级调度|从就绪队列中选择进程分配处理机|内存→CPU|高|就绪态→运行态|

### 进程/低级调度
主动放弃
- 进程正常终止
- 发生异常终止
- 主动请求阻塞（等待I/O）

被动放弃
- 时间片用完
- 优先级更高的进程进入就绪队列
- 更紧急的事情需处理（I/O中断）

不能进行调度
- 处理中断过程
- 在操作系统**内核程序临界区**（非普通临界区）
- 在原语操作过程


### 计算
- CPU利用率 忙碌时间/总时间
- 系统吞吐量 完成作业总数/总时间
- 周转时间 完成时间-提交时间
- 平均周转时间 总周转时间/作业数
- 带权周转时间 周转时间/实际运行时间
- 等待时间
  - 进程 建立后等待被服务时间之和（不含等待I/O完成）
  - 作业 建立后的等待时间与在外存后备队列中等待时间之和
- 响应时间

### 批处理调度算法

#### 先来先服务FCFS

#### 短时间优先SJF/短进程优先SPF
> 抢占式版本为最短剩余时间优先SRTN
> 几乎同时到达时，平均等待时间和平均周转时间最少

#### 高响应比优先HRRN
> 非抢占式，响应比 = （等待时间 + 要求服务时间）/ 要求服务时间

### 交互式调度算法

#### 时间片轮转RR
> 进程调度
新到达的进程先进入就绪**队列**（先进先出）

#### 优先级

#### 多级反馈队列
- 多级就绪队列，优先级从高到低，时间片从小到大
- 使用完时间片还未结束，则进入下一级队列，最多放到最下级队列，然后循环
- 上一级队列为空时，才为下一级对头的进程分配时间片

#### 多级队列
- 设置多个队列，采用不同调度策略

### 多处理机调度
- 负载均衡
- 处理机均衡性

公共就绪队列
- 可以天然实现负载均衡
- 亲和性不好
  - 软亲和 进程调度尽量保证亲和性
  - 硬亲和 由用户进程通过系统调用保证亲和性

私有就绪队列
> 天然实现处理机亲核心
- 推迁移 **特定系统程序**将忙碌CPU的就绪队列推送到空闲CPU上
- 拉迁移 每个CPU检查自身和其他CPU负载，将其他忙碌CPU的就绪队列拉到自己的就绪队列


## 同步和互斥
空闲让进，忙则等待，有限等待，让权等待

互斥的软件实现
- 单标志法（对方一直不使用时虽空闲仍无法使用）
- 双标志先检查（先检查再锁定）
- 双标志后检查（先锁定再检查）
- Peterson算法（要求-谦让-检查，先谦让者先使用）

互斥的硬件实现
- 中断屏蔽（不适用多处理机，不适用用户进程）
- TestAndSet指令
- Swap指令（均不满足让权等待）

互斥锁

信号量
- 整型信号量
- 记录型信号量
P操作 wait原语 请求资源 运行态→阻塞态 先S.value--可能再block
**V操作** signal原语 释放资源 阻塞态→就绪态 先S.value++可能再wakeup
什么时候需要执行block或wakeup

信号量机制
进程互斥
  - mutex = 1
  - 临界区之前执行P
  - 临界区之后执行V
进程同步
  - 信号量由资源数确定
  - 在前操作之后执行V
  - 在后操作之前执行P
进程前驱关系

生产者-消费者问题
多生产者-多消费者问题
读者-写者问题
哲学家进餐问题 循环等待


管程
> 每次仅允许**一个进程**在管程内执行某个内部过程
> 由编译器实现互斥

- 管程的共享数据结构说明
- 对数据结构进行操作的一组过程（函数）
- 对管程的共享数据设置初始值的语句

wait 阻塞
signal 唤醒


## 死锁
1. 预防 破坏四个必要条件
2. 避免 防止系统进入不安全状态

死锁避免的n进程最小资源m数量公式R=n×(m−1)+1

资源分配图
分配边 指向进程
请求边 离开进程
方框 资源

系统发生死锁的充要条件是：
系统的资源分配图中存在环路，且该环路中的每个节点（进程）都已保持至少一种资源（即图中所有边均为“分配边”，无“请求边”）。

# 内存管理
> 分配与回收内存空间
> 扩充内存空间
> - 覆盖
> - 交换
> - 虚拟存储
> 转换逻辑地址与物理地址
> 内存保护
> - 重定位寄存器（基址寄存器）：起始物理地址
> - 界地址寄存器（限长寄存器）：最大逻辑地址

装入
> 将模块装入内存运行
- 绝对
- 可重定位
- 动态运行时

交换与覆盖
> 覆盖在同一进程或程序内
> 交换在不同进程或作业
- 覆盖
  - 一个固定区 存放最活跃程序段
  - 若干覆盖区 不可能同时被访问程序段共享同一覆盖区
- 交换
  - 换出某些进程腾出内存空间
  - 换出的进程放在对换区（PCB常驻）


进程的内存映像
- 操作系统内核区 `内核代码、内核数据` 进程控制块PCB
- 用户栈 `各函数的栈帧，含局部变量和函数调用` 在大括号内定义的局部变量、函数调用时传入的参数
- 共享库的存储映射区 `库` 被调用的库函数
- 堆 `malloc/free分配的区域` `malloc/free`分配回收的数据
- 读/写数据 `全局变量、静态变量` 定义在函数外的全局变量、由`static`修饰的变量
- 只读代码/数据 `程序指令、只读数据` 程序代码、由`const`修饰的常变量
- 未使用区
> 宏定义在预编译阶段会直接替换代码中的对应内容

## 连续分配管理（以程序为基本单位）
> 内部碎片 分配给某进程的内存空间空闲
> 外部碎片 某些空闲分区太小难以利用
> 最节约性能
- 单一连续分配
- 固定分区分配（分区说明表）
  - 分区大小相等
  - 分区大小不等
- 动态分区分配（空闲分区表/链）

### 动态分配分区算法
> 重新排序的算法开销大
- **首次适应算法** 从低地址开始查找
- **最佳适应算法** 从小容量开始查找（外部碎片）
- **最坏/大适应算法** 从大容量开始查找（大分区容易被用完）
- **邻近适应算法** 从上次结束处开始查找（高地址的大分区易被用完）

## 非连续分配管理（拆分程序）

### 分页存储管理（按地址分页）
> 为了实现离散分配和提高内存利用率
- 页框号（内存）、页号（进程）从0开始，大小相等
- K位页内偏移量，则有$2^K$个内存单元
-  M位页号，则有$2^M$个页面

N位页号表示一页能存2^N个页表项

- 具有块表的地址变换机构
> 快表/联想寄存器TLB

- 多级页表
> 页表大小不能超过一个页面

访存次数：n级页表需要访存n+1次，如果TLB命中则仅需要一次

基本地址变换机构MMU
1. 计算页号P=逻辑地址A/页面大小L和页内偏移量W
2. 若页号P$\geq$页表长度M，则产生越界中断（页表长度至少为1，但是页号从0开始）
3. 页表项地址=页表起始地址F+页号P*页表项长度
   - 页表项长度：每个页占多大空间
4. 物理地址E=b*页面大小L+页内偏移量W
> 权限检查、缺页中断、TLB缺失（Cache缺失无法检测）

### 分段存储管理（按逻辑功能分段）

作用
- 方便编程、分段共享、分段保护、动态链接和动态增长

> 页是物理单位，对用户不可见，分页地址空间为一维
> 段是逻辑单位，对用户可见，分段地址空间为二维

### 段页式存储管理

访存次数：

## 虚拟内存
> 对应用透明，对系统不透明


**局部性原理**
- 时间局部性
- 空间局部性
> 未使用的部分放在外存


**请求分页存储管理**
- 内存块号
- 状态位 是否已调入内存
- 访问字段 上次被访时间/被访次数
- 修改位
- 外存地址

### 缺页中断机构

### 地址变换机构

### 页面置换算法
最佳置换算法OPT
> 以后永不使用/最长时间内不再被访问页面（往后数最远的）
> 无法实现

先进先出置换算法FIFO
> 存在Belady异常，性能较差

最近最久未使用置换算法LRU
> 往前数最晚一个没用到的
> 性能好但花销大

时钟置换算法CLOCK/最近未用算法NRU
> 置访问位，近期使用过为1，未使用过为0，扫描后1置0

改进型时钟置换算法
> 置修改位（若页面未修改则无需写回内存）
> 1. 找第一个(0,0)的帧进行替换，不修改标志位（没访问且没修改）
> 2. 找第一个(0,1)的帧进行替换，访问位置0（没访问但修改）
> 3. 找第一个(0,0)的帧进行替换，不修改标志位（访问但没修改）
> 4. 找第一个(0,1)的帧进行替换（访问且修改）

### 页面分配策略
驻留集（系统分配的内存块集合）
- 固定分配/可变分配：驻留集大小是否可变
- 局部置换/全局置换：是否只能从自己的页面选择换出
工作集（实际访问的页面集合）
- 一般不能大于驻留集

固定分配局部置换：运行前分配物理块，只能换出自己的某个页面
可变分配全局置换：只要缺页就分配新物理块，可能来自空闲物理块，也可能换出别的进程页面
可变分配局部置换：频繁缺页的基础多分配一些物理块，缺页率低的进程回收一些物理块

交换区利用率高
- 减少多道程序度数
- 使用更快的交换区
- 扩大容量

### 内存映射管理


# 文件管理

> 磁盘读写次数
 
## 逻辑结构（用户视角：存储）
无结构文件（流式文件）
有结构文件（记录式文件）：定长/**可变长记录（无法随机存取）**
- 顺序文件
  - 顺序/**链式存储（无法随机存取）**
  - 串/顺序结构（记录顺序与关键字是否有关）
- 索引文件（按单个记录索引）
- 索引顺序文件（按分组索引）

## 文件目录
文件控制块FCB：**文件名**、**物理地址**和操作（口令）
目录结构
- 单级目录：不适用多用户
- 两级目录：主文件目录（用户名、存放位置）、用户文件目录
- 多级/树形目录：不便于文件共享
- 无环图目录
  - 用不同的文件名指向同一目录
  - 置共享计数器，为0时才删除节点
索引节点：文件名、索引节点指针

## 物理结构（系统视角：分配）
连续分配（逻辑相邻，物理也相邻）：首块地址、文件长度
> 顺序随机读写时最快
> 不方便在中间增删，碎片空间利用率低
链接分配
- 隐式链接（默认）：起始块号、结束块号和指针（对用户透明）
  > 不支持随机存取，每一物理块需要花费少量空间
- 显式链接：（FAT表一个磁盘一张存放内存中）起始块号
  > 支持随机存取，不需要访问磁盘
  > FAT记录了空闲
索引分配（一个文件一张）
- 索引块（存放索引表）：物理块号
- 磁盘块（存放文件数据）
1. 链接索引：指针链接下一个磁盘块
2. 多层索引
3. 混合索引：直接地址索引、一级间接索引、……
> 读磁盘次数：FCB是否已读入内存（1次）、**读入一级索引块**（1次）
> FCB大小*目录项数量/两倍盘块大小=平均访盘次数
> n层索引文件大小：每个盘能存几个索引：（大小/地址占用）$^n$*大小 

> 逻辑结构与物理结构

## 文件存储空间管理（空闲空间）
逻辑卷/文件卷、物理磁盘

空闲表（连续分配）

空闲链表（离散分配）：连头、链尾
- 空闲盘块链
- 空闲盘区链（连续空闲盘块）
  > 不适用大型文件系统

位示图（连续、离散）
- 0空1满
- （字号i，位号j）→盘块号$b=ni+j$（从0开始）
- （字号i，位号j）→盘块号$b=n(i-1)+(j-1)$（从1开始，若反求则需+1）
- 位图所需大小=总空间大小/块大小/8（bit换算Byte）
> 

成组链接
- 超级块：下一组空闲盘块数量、空闲块号（倒数第二个分组首个盘块号置`-1`）
- 分配：分配满时将下一组的信息复制到超级块中
- 回收：回收满时超级块指向新分组
  > 内存中有空闲盘块号栈

## 基本操作
- 创建`create`：大小、路径、文件名
  - 找到空间、创建目录项
- 删除`delete`：路径、文件名
  - 找到目录项、回收磁盘块、删除目录项
- 打开`open`：路径、文件名、操作类型
  - 找到目录项（确定权限）、将目录项复制到内存“打开文件表”中
  - 进程打开文件表：读写指针、访问权限、系统表索引号…… 
  - 系统打开文件表（仅有1张）：编号、打开计数器……
  > 打开文件时不会读入内存
  > 索引号也称文件描述符
- 关闭`close`
  - 删除打开文件表、回收内存空间、打开计数器-1，为`0`则删除表项
- 读`read`
  - read系统调用：打开文件表索引号、读入数据量、读入数据内存位置
- 写`write`
  - write系统调用：打开文件表索引号、写入数据量、写入数据内存位置
> `open`会返回文件描述符，只有`open`能按名查找

## 文件共享
基于索引节点（硬链接）
- 索引节点置链接计数变量count
基于符号链（软链接）
- 建立Link类型文件指向原文件
  > 需要多次磁盘I/O
> 引用计数值：
> - 打开F1后索引节点读入内存
> - 软链接不影响源文件引用计数值，恒为1


## 文件保护
口令、加密（异或）、访问控制

## 文件系统
用户接口
文件目录系统
存取控制模块
逻辑文件系统与文件信息缓冲区
物理文件系统
设备管理程序模块
辅助分配模块

物理/低级格式化：使用备用扇区替代坏扇区（对操作系统透明）
逻辑/高级格式化：分区

### 虚拟文件系统

挂载
- 挂载表
- 函数地址列表
- 挂载点

# 输入/输出管理

分类
使用特性：人机交互类外部设备、存储设备、网络通信设备
传输速率：低速、中速、高速
信息交换单位：
- 块设备（传输快，可寻址）
- 字符设备（传输慢，不可寻址，常采用中断驱动）
共享属性：独占、共享、虚拟

## I/O设备

### I/O控制器
- 接受识别CPU命令（控制寄存器）
- 向CPU报告设备状态（状态寄存器）
- 数据交换（数据寄存器）
- 地址识别（I/O逻辑）

组成
- CPU与控制器间接口
- I/O逻辑（识别CPU命令并向设备发出命令，实现设备控制）
- 控制器与设备间接口

寄存器编制方式
- 内存映像I/O（采用内存操作指令操作控制器）
- 寄存器独立编址（设置专门指令操作控制器）

### I/O控制方式

**程序直接控制**：轮询、单位 字
1. CPU发出指令（CPU→I/O）
2. 轮询检查控制器状态（I/O→CPU）
3. 传输数据并报告自身状态
4. 存放数据至数据寄存器，修改状态
5. 读取数据寄存器至CPU寄存器→放入内存（I/O→CPU，CPU→存储器）

**中断驱动**：指令周期末尾检查中断（并行）、单位 字
> 频繁中断耗费CPU时间
> 只有中断驱动会导致进程进入阻塞态

**直接存储器存取DMA**：单位 块
- 开始和结束才需要CPU
- 数据读取不需要经过CPU

1. 初始化DMA、启动设备
2. 从设备传输数据到内存
3. DMA控制器发出中断请求
4. 执行DMA结束中断服务程序

DR数据寄存器
MAR内存地址寄存器
DC数据计数器
CR命令/状态寄存器
> 每条CPU指令只能读写一个或多个连续数据块

**通道控制**：单位 一组块
通道（硬件）：识别并执行一系列通道指令
1. CPU向通道发出I/O指令（通道程序的内存位置、指明I/O设备）
2. 执行通道程序（读写数据量、数据的内存位置）
3. 读写完毕后向CPU进行中断处理

### I/O软件层次
【库函数】**用户层软件**：提供用户交互接口，将请求翻译成I/O请求，请求系统内核
  > 设备无关、语言相关的（假脱机技术SPOOLing）

【系统调用】**设备独立性软件**：**提供统一调用接口**、**保护设备**、差错处理、设备分配与回收、数据缓冲区处理、建立逻辑设备到物理设备的映射（逻辑设备LUT：系统一张/用户一张）、选择驱动
  > 统一访问，将命令转化，用户设备与实际设备无关
  > - 用某种算法确定I/O顺序

**设备驱动程序**：将上层命令（如`read`）转换成设备操作（如设置设备寄存器）
  > 对接控制器，也需要处理中断，接受命令和参数（不包括分析和缓冲）
  > 1. 将抽象要求转化为具体
  > 2. 对服务请求进行校验
  > 3. 检查设备状态
  > 4. 传递参数
  > 5. 启动I/O设备

**中断处理程序**：根据中断信号类型处理
  > 中断后存放在内核缓冲区

硬件

## 输入输出应用程序接口

字符设备接口：`get`/`put`读写字符
块设备接口:`read`/`write`读写指针位置、`seek`修改读写指针位置
网络设备接口:`socket`网络套接字接口（一片内核空间），将指明UDP/TCP类型的套接字绑定至端口
> 设备独立性软件的缓冲区放到这片内核空间中，调用网络控制器驱动程序

- 阻塞和非阻塞I/O：系统调用后是否需要转为阻塞态

## SPOOLing假脱机技术

- 预输入、井管理、缓输出（不需要设备）
输入输出设备 ↔ 输入/输出缓冲区（内存） ↔ 输入/输出井（磁盘）

## 设备分配与回收

分配考虑因素
- 固有属性：独占、共享、虚拟
- 分配算法：先来先服务、优先级、短任务……
- 安全性：安全分配方式（为进程分配设备后阻塞）、不安全分配方式（一个进程使用多个设备）
> 类型、访问权限、占用状态、逻辑设备与物理设备的映射关系

分配方式
- 静态分配（分配全部资源）独占设备
- 动态分配

通道→设备控制器→设备

### 数据结构

**系统设备表SDT**
- 表目
    - 设备类型
    - 设备标识符
    - 设备控制表DCT
    - 驱动程序入口

**设备控制表DCT**
- 设备类型
- 设备标识符
- 设备状态
- 指向控制器表指针
- 重复执行次数/时间：
- 设备队列的队首指针：指向等待该设备的进程队列（进程PCB组成）

**控制器控制表COCT**
- 控制器标识符
- 控制器状态
- 指向通道表指针
- 控制器队列的队首指针
- 控制器队列的队尾指针：指向正在等待该控制器的进程队列

**通道控制表CHCT**
- 通道标识符
- 通道状态
- 与通道连接的控制器表首址
- 通道队列的队首指针

### 分配步骤

1. 根据物理设备名查找**系统设备表SDT**
2. 根据**系统设备表SDT**查找**设备控制表DCT**
3. 根据**设备控制表DCT**查找**控制器控制表COCT**
4. 根据**控制器控制表COCT**查找**通道控制表CHCT**
> 若设备/控制器/通道忙碌则将进程PCB加入对应等待队列中
> 缺点：必须要求“物理设备名”、请求的设备忙碌时无法自动更换空闲同类型设备

**改进**

1. 根据**逻辑设备名**查找**系统设备表SDT**
2. 根据**系统设备表SDT**找到用户进程指定且空闲的设备（全忙则阻塞），在**逻辑设备表LUT**中新增表项
> 逻辑设备表LUT建立逻辑设备名与物理设备名（以及驱动程序入口地址）的映射关系
> 系统一张LUT：不允许重复；用户一张LUT：不同用户逻辑设备名可重复

## 缓冲区管理（内存）

作用
- 缓和CPU与I/O设备速度不匹配矛盾
- 减少CPU中断频率
- 解决数据粒度不匹配问题（单位 字与单位 块）
- 提高CPU与I/O设备并行性
> 为空才能冲入，全满才能传出

**单缓冲**（单向）
> 初始状态：工作区满，缓冲区空
> 1. CPU处理时间C与冲入缓冲区时间T（二操作并行）
> 2. 缓冲区传输时间M
> 总时间Max(C,T)+M

**双缓冲**（双向）
> 初始状态：工作区空，缓冲区A满，缓冲区B空
> 1. 缓冲区A传输时间M
> 2. CPU处理时间C
> 3. 冲入缓存区时间T（与前两步并行）
> 总时间Max(T,C+M)

**循环缓冲** 多个大小相等的缓冲区连接

**缓冲池** 
使用状况：空缓冲队列、输入队列、输出队列
功能：收容输入`hin`、提取输入`sin`、提取输出`sout`、收容输出`hout`

## 磁盘
> 柱面号3，盘面号2，扇区号3

初始化
1. 低级格式化（划分扇区）
2. 分区
3. 逻辑格式化（建立文件系统：根目录文件、数据结构）

引导块
- 自举程序：由自举装入程序找到引导块，再将完整自举程序读入内存

坏块
- 使用FAT标明（不透明）
- 扇区备用（备用）

磁盘是否可移动
- 固定头磁盘（每磁道一个磁头）
- 移动头磁盘（每盘面一个磁头）

盘片是否可更换
- 固定头磁盘
- 可换盘磁盘

### 读/写时间
- 寻找/道时间（定位磁道时间）$T_s$ $=$启动磁头臂$s$ $+$ 跨越单一磁道耗时$m$ $*$ 磁道数$n$
- 延迟时间（旋转磁盘时间）$T_R$ $=$ $\cfrac{1}{2}$ $*$ 转速r的磁盘转一圈所需时间$\cfrac{1}{r}$ $=$ $\cfrac{1}{2r}$
> 经典转速为5400转/分或7200转/分
- 传输时间$T_t$ $=$ 读写一个磁道所需时间为一圈$\cfrac{1}{r}$ $*$ 数据长度为b且磁道容量N $b/N$ $=$ $\cfrac{b}{rN}$
- 总平均存取时间$T_a$ $=$ $T_s$ $+$ $\cfrac{1}{2r}$ $+$ $\cfrac{b}{rN}$

**降低延迟时间**
- 交替编号（间隔1个扇区）
- 错位命名（）

### 磁盘调度算法

- 先来先服务FCFS（性能差）
- 最短寻找时间SSTF（可能饥饿）
- 扫描SCAN：单向移动直到边缘然后反向（产生无用移动，两边的响应时间长）
- LOOK：单向移动直到没有别的请求，回到边缘
- 循环扫描C-SCAN：单向移动直到边缘然后回到起点，仅有往一侧移动时才处理请求
- C-LOOK：单向移动直到没有别的请求，返回第一个有请求处

## 固态硬盘

读写单位：页（磁盘为扇区）
擦除单位：块（写一次读无限次）
> 要写的页有数据，则要将块内其他页复制到被擦除国的块中再擦除写入
> 一个块被擦除次数过多会坏

动态**磨损均衡**：写入时选择新闪存块；静态**磨损均衡**：没写入时让老旧的闪存块承担更多读任务